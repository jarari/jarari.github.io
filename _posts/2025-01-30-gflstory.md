---
title: >
    소녀전선 2 스토리 뷰어 제작기 (1) 데이터 수집
tags: [GFL2, React]
style: border
color: primary
description: >
    스토리를 편하게 읽고 싶어서 웹사이트를 만들게 된 이야기
---
![GFL2](assets/gfl2.jpg)
소녀전선은 2016년 첫 출시 이후 오랜 시간동안 많은 사람들에게 사랑받고 있는 IP입니다. 저도 옛날에 짧게나마 2년 정도 즐겼던 기억이 있고, 마침 소녀전선 2: 망명 한국 서버가 출시되었다기에 플레이 해 보았습니다. 역시 스토리가 읽을 수록 더욱 궁금해지는 작품이었습니다. 그래서 저는 현재 중국 서버 클라이언트에 나와있는 스토리까지 모두 추출한 뒤 파싱하여 읽을 수 있는 방법이 없을까 고민해보았고, 이를 위해 웹사이트를 처음으로 만들어보기로 하였습니다.<br>
<br>
### 본격적인 데이터 준비
이 게임은 UnityCN으로 만들어졌지만 UnityCN의 암호화 번들을 사용하지 않는 특이한 게임입니다. 암호는 설정되어 있지만, 실제 복호화는 단순히 16바이트 키로 전체 파일을 0x8000바이트까지 XOR하는 것이 전부였습니다. 이에 더해, 보통 다른 게임들이 json 형태로 저장하던 데이터 설정값들을 이 게임은 Protobuf 메세지로 보관한다는 것도 알게 되었습니다. 암호화도 전혀 없지만 사실 프로토버프 메세지로 보관하게 되면 아무리 메세지를 해독해봤자 구조를 모르는 이상 데이터의 내용을 알려면 코드만 주구장창 읽고 있어야한다는 장점이 있습니다. 여기에 컴파일 타임에 불필요한 dll을 다 빼놓고 hybridclr을 이용해 핫로드하는 방식과 Beebyte 난독기를 더한다면 금상첨화겠죠?<br>
![GFL2Beta](assets/gfl2beta.png)
썬본의 한가지 실수라면, 클로즈 베타 클라이언트는 이러한 과정을 모두 스킵하고 Mono로 그대로 빌드했다는 점입니다. 디스코드의 데이터마이너를 통해 베타 시절의 dll 파일을 입수하였고, 다소 많은 부분이 변경되거나 추가되어 로드되지 못하는 파일들도 있었으나 프로토버프 메세지를 다수 해독할 수 있었습니다. 이후 필요에 따라 CyberChef와 Protobuf Decoder를 이용하여 필요한 메세지들을 해독하였습니다.<br>
<br>
이 과정에서 테이블 로딩 시간 최적화 기법을 확인할 수 있었는데요. 게임 시작 시 모든 데이터를 로드하여 메모리에 올려놓는 대부분의 게임들과 달리 이 게임에서 사용되는 테이블들은 필요한 부분만 딱 딱 읽어올 수 있는 구조를 가지고 있었습니다. 이상하게도 테이블이 모두 두 개의 프로토버프 메세지로 구성되어 있다는 것을 확인하였는데, 첫 번째 프로토버프 메세지는 파일의 id를 색인해둔 메세지인 것으로 확인되었습니다.<br>

![GFL2TableHeader](assets/gfl2tableheader.png "테이블 헤더 메세지의 구조") | ![GFL2TableEditor](assets/gfl2tableeditor.png "파이썬으로 작성한 테이블 에디터")

테이블 헤더의 sectioned는 해당 테이블이 id값을 이용한 섹션 색인을 사용하는지에 대한 여부를 나타내고, distance는 id를 나눌 값을 정합니다. index는 distance로 나누어진 id값을 이용하여 만든 섹션을 담아두는 필드입니다. 우측의 에디터를 보시면 id값이 31500입니다. 이 테이블의 distance는 10이기 때문에 31500 / 10 = 3150, 그러므로 31500, 31501, 31502 ... id를 가진 값들은 모두 섹션 3150에 묶이게 됩니다. 각 섹션의 시작 오프셋과 길이가 기록되어 있기 때문에, 게임에서 스트링 id 31501을 읽어와야하는 경우가 생긴다면 바로 불러온 파일의 섹션 3150의 beginOffset으로 이동하여 메세지를 해독하고 스트링을 리턴하게 됩니다. 이를 통해 파일 전체를 파싱할 필요 없이 필요한 값만 바로 찾아올 수 있는게 빠른 로딩의 비결인 것입니다.<br>
다만, 이 방법의 단점은 누군가가 이 구조를 정확하게 모방한 파일을 제작한다면 파일 검증이 불가능하다는 점입니다. 파일 크기든, 체크섬이든 파일 전체를 한 번 읽게된다는 문제가 있는데 여기서 이미 해당 알고리즘을 적용한 이유 자체가 사라지게 됩니다. 따라서, 보안이 중요하거나 변조를 막아야하는 파일에는 적용하기 어려운 방법인 것 같습니다.<br>
<br>
이후 추가적인 리버싱을 통해 스토리 대화문은 AdvEngine 클래스가 에셋 번들에서 AdvChapterData, AdvScenarioData, AdvImportBook 등의 ScriptableObject를 통해 불러온다는 점, 그리고 해당 파일들의 스트링값은 AvgContentData 테이블에서 불러온다는 것을 알게되었으나... 예상치도 못한 난관에 부딪치게 됩니다.