---
name: 테무에서 산 스타레일
tools: [C#]
image: assets/temustarrail.png
description: "유니티 C#을 이용한 3D 행동력 기반 턴제 RPG. Honkai: Star Rail 모작"
---

# 테무에서 산 스타레일
![타이틀](assets/temustarrail2.png)
Unity 6000.0.45 버전으로 제작한 붕괴: 스타레일 모작 3D 행동력 기반 턴제 RPG입니다.<br>
4명이 팀으로 4주간 작업하였으며, 일정 관리 및 코드 문서는 디스코드를 통해서, 프로젝트 관리는 Git을 이용하였습니다.

## 담당 파트 영상
{% include elements/video.html id="UqqNfITYdWE" %}


<p class="text-center">
{% include elements/button.html link="https://github.com/jarari/TurnBasedPortfolio" text="프로젝트 GitHub" %}
</p>

## 팀 작업 규칙

해당 프로젝트는 프로그래머 4명이서 작업한 만큼 혼선이 생기지 않도록 규칙을 정하여 작업하였습니다.<br>
1. 일정 관리는 디스코드를 이용
2. 코드 공유는 Git으로, 각 기능마다 branch를 만들어 main과 동기화 후 pull request
![코드 문서](assets/temustarrail3.png)
3. 코드 작성 후에는 #코드-문서 채널에 정리
4. Scene은 자동 병합이 안되므로 복제해서 작업 후 에디터를 통해 변경점만 병합
5. 버그 발생, 코드에 의문 사항이 있으면 바로 연락
6. 기획은 다 같이 상의하며 접근

## 담당 파트

저는 메인 전투 프로그래머로서 **전투씬의 흐름, 전투 연출, 캐릭터 기반, 행동력 기반 턴 시스템, 버프 시스템, 스탯 시스템, 적 웨이브 진행, 사운드**를 담당하였습니다.

### 1. 턴 시스템

![턴 시스템 개요](assets/temustarrail4.png)

![행동력 시스템 개요](assets/temustarrail5.png)

턴은 스타레일의 행동력 시스템과 동일하게 10000의 거리를 각 캐릭터의 속도를 이동하는 경주로 추상화하여 구현하였습니다.<br>
<br>
일반턴, 궁극기턴, 추가공격턴 총 3가지의 턴이 존재하며, 턴 매니저에 리스트로 구현된 턴 큐를 이용해서 가장 빨리 도달하는 캐릭터가 턴을 잡게 되고, 해당 턴에 기록된 시간만큼 다른 캐릭터들 또한 시간 * 속도의 거리를 이동하게 됩니다.<br>
<br>
캐릭터 매니저가 캐릭터를 생성하면 턴 매니저에 일반턴이 추가되고, 궁극기나 추가공격 발생 시 현재 행동중인 캐릭터의 뒤에 추가됩니다. 예외적으로 현재 행동중인 캐릭터가 아군 캐릭터인 경우 궁극기를 발동한 캐릭터가 턴을 당겨서 행동할 수 있습니다. 캐릭터가 사망한 경우 해당 캐릭터의 턴과 그 캐릭터를 타겟으로 하는 추가공격 턴이 모두 제거됩니다.<br>
<br>
턴의 흐름은 각종 이벤트와 콜백 형식의 TurnContext를 이용하여 관리됩니다. 보통 턴 시작 직전과 턴 종료 후 버프 효과가 발동하는 경우가 있는데, 이 때 연출을 위해 턴 진행을 잠시 중단시킬 수 있습니다. 또한, 적이 사망한 경우 로직 충돌 방지를 위해 턴 진행이 중단됩니다. 이는 코루틴과 이벤트를 이용하여 구현하였습니다.<br>

### 2. 컨텍스트 기반 카메라

![컨텍스트 기반 카메라 개요](assets/temustarrail6.png)

ContextualIdleCamera 는 캐릭터 턴 시작/종료 이벤트와 타겟 업데이트 이벤트, 그리고 CinemachineCameraManagerBase 를 이용하여 현재 상황에 가장 적절한 시네머신 카메라를 활성화시키는 컴포넌트입니다.<br>
추가적인 연출이 필요할 때 바로 추가하고 위치를 수정할 수 있도록 확장성을 염두에 두고 설계하였으며, 맵에 미리 배치하여 적과 아군이 적절하게 화면에 담길 수 있도록 구성하였습니다.

### 3. 타겟 매니저

![타겟 매니저 개요](assets/temustarrail7.png)

타겟 매니저는 아군, 적, 생존, 1인, 3인 등 필터를 기반으로 캐릭터를 선택할 수 있게 도와주는 싱글톤 매니저입니다.<br>
세팅 변경, 왼쪽 캐릭터 선택, 오른쪽 캐릭터 선택, 현재 타겟 반환 같이 범용성있고 필수적인 함수만 구현하여 키보드, 게임패드 등 어떤 방식이든 대응할 수 있도록 구현하였습니다.

### 4. 전투씬 캐릭터

![캐릭터 개요](assets/temustarrail8.png)

캐릭터의 각 행동들을 추상 클래스 Character에 구현한 후, 실제 캐릭터는 해당 클래스를 상속하고 함수들을 오버라이드 하는 방식으로 구성하였습니다. 이를 통해 새 캐릭터를 추가할 때 빠르고 안정적으로 작업이 가능하도록 하였습니다.<br>
또한, 각 캐릭터들의 데이터는 ScriptableObject로 관리되며, 캐릭터 데이터에 연결된 별개의 ScriptableObject인 CharacterAttackTable을 통해 각 공격의 계수와 강인도 피해를 가져올 수 있도록 구성하였습니다.<br>
{% include elements/figure.html image="projects/assets/temustarrail8_1.png" caption="콜펜의 캐릭터 데이터 예시" %}

### 5. 버프와 스탯 시스템

![버프/스탯 개요](assets/temustarrail9.png)

버프와 스탯 시스템은 ScriptableObject와 인터페이스 상속 구조를 최대한 활용하여 일관성있게 적용/해제되면서 효과 재활용, 확장까지 염두에 두고 구성하였습니다.<br>
<br>
먼저, 스탯은 캐릭터 소환 시 CharacterData를 통해 CharacterDataInstance가 생성됩니다. 이 클래스에는 Stat 이라는 별도의 클래스로 구현된 각종 스탯 데이터가 담겨 있으며, 각 스탯들은 베이스, 현재값, 최소/최대값을 가집니다.<br>
StatModifier가 추가되면 Additive, Multiply, Set의 순서로 베이스 스텟에 적용되며, 다른 코드에서는 캐릭터 데이터 인스턴스 스탯의 현재값을 가져오는 형태로 바로 현재 스탯을 가져올 수 있습니다.<br>
<br>
버프는 캐릭터 프리팹에 부착된 CharacterBuffSystem 컴포넌트를 통해 관리됩니다.<br>
지속 시간이 있는 버프는 일반턴 종료 시 남은 시간이 차감되고 제거되며, 적용 시/해제 시/일반턴 시작 시/일반턴 종료 시 각각 이펙트가 발동됩니다. 조건에 따른 활성화/비활성화는 기획에 포함되어 있지 않아 구현하지 않았지만, 이 또한 ScriptableObject를 활용하면 여러 컨디션을 디자이너가 자유자재로 추가할 수 있는 형태로 구현할 수 있을 것입니다.<br>
<br>
버프 데이터는 버프 목록에 버프를 등록시키는 버프 테이블, 스탯/효과/지속 시간/중첩 가능/최대 중첩 수 등의 설정을 저장하는 버프 데이터, 효과를 정의하는 BuffEffectDefinition으로 구분됩니다. 이러한 구조를 통해 각 버프의 효과를 프로그래밍하고 그에 맞는 ScriptableObject만 정의해주면 어디에든 재활용 가능할 수 있도록 하였고, 모든 데이터를 ScriptableObject로 구현하여 디자이너가 버프의 실제 작동 방식을 한 눈에 보고 수정할 수 있도록 하였습니다. 위 그림에서 DamageOnTurnStartEffect는 이 구조를 사용한 효과의 예시로, 턴 시작 시 해당 디버프를 보유한 캐릭터에게 데미지를 주는 효과입니다.<br>
{% include elements/figure.html image="projects/assets/temustarrail9_1.png" caption="양자 격파 얽힘 버프 데이터 예시" %}

### 6. 사운드 시스템

![사운드 시스템 개요](assets/temustarrail10.png)

사운드 시스템은 ScriptableObject 형태의 SoundPack에 사운드명, 오디오클립을 등록하고, 씬에 배치된 사운드 매니저 싱글톤에 사운드팩들을 할당해주는 방식으로 구현하였습니다.<br>
용도나 캐릭터별로 사운드를 분리하여 관리할 수 있으므로 차후 리소스가 많아져 동적 로딩이 필요한 경우, 필요한 리소스만 캐싱하도록 확장할 수 있을 것으로 기대되며, Wwise나 CRIWARE같은 오디오 미들웨어를 사용한다면 그 전까지 프로토타입용으로 충분히 역할을 할 수 있는 구조라고 생각됩니다.